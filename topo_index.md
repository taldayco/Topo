# Project Index

IMORTANT:

> only build topo in the build directory.
> DO NOT output verbose explanations or thoughts as you work, remember this.

- Topo/
  - shaders/
  - src/
    - engine/
      - app.cpp
        - `int Application::run()` — calls `on_pre_frame_game` before `gpu_acquire_game_frame` each game frame
      - app.h
        - `int run()`
        - `virtual void on_init(GpuContext &gpu, flecs::world &ecs)`
        - `virtual void on_event(const SDL_Event &event, flecs::world &ecs)`
        - `virtual void on_render_tool(GpuContext &gpu, FrameContext &frame, flecs::world &ecs)`
        - `virtual void on_render_game(GpuContext &gpu, FrameContext &frame, flecs::world &ecs)`
        - `virtual void on_pre_frame_game(GpuContext &gpu, flecs::world &ecs)` — default no-op; called before `gpu_acquire_game_frame`; safe to call `SDL_WaitForGPUIdle` here (no frame cmd buffer open)
        - `virtual void on_cleanup(flecs::world &ecs)`
        - `virtual bool wants_game_window_open(flecs::world &ecs)`
        - `virtual bool wants_game_window_close(flecs::world &ecs)`
        - `void request_quit()`
        - `AssetManager asset_manager` — member of Application
      - camera/
        - camera.cpp
          - `static float lerp(float a, float b, float t)`
          - `void CameraSystem::update(CameraState &cam, float dt)`
          - `void CameraSystem::follow(CameraState &cam, float target_x, float target_y)`
          - `void CameraSystem::stop_follow(CameraState &cam)`
          - `void CameraSystem::shake(CameraState &cam, float intensity, float duration)`
          - `void CameraSystem::set_zoom(CameraState &cam, float zoom)`
          - `void CameraSystem::apply_to_view(const CameraState &cam, ViewState &view)`
        - camera.h
          - `public: void update(CameraState &cam, float dt)`
          - `void follow(CameraState &cam, float target_x, float target_y)`
          - `void stop_follow(CameraState &cam)`
          - `void shake(CameraState &cam, float intensity, float duration)`
          - `void set_zoom(CameraState &cam, float zoom)`
          - `void apply_to_view(const CameraState &cam, ViewState &view)`
          - `CameraMatrices build_matrices(const CameraState &cam, float aspect) const`
          - `struct CameraMatrices` — glm::mat4 view, projection
      - core/
        - task_system.h
          - `void TaskSystem::init(int num_threads)` — spawn std::thread pool
          - `void TaskSystem::shutdown()` — signal stop, join all threads
          - `void TaskSystem::enqueue(std::function<void()> task)` — push onto deque
          - `bool TaskSystem::is_idle() const` — true when queue empty and no threads active
        - task_system.cpp
          - `void TaskSystem::init(int num_threads)`
          - `void TaskSystem::shutdown()`
          - `void TaskSystem::enqueue(std::function<void()> task)`
          - `bool TaskSystem::is_idle() const`
          - `void TaskSystem::worker_loop()` — internal thread body
        - asset_manager.h
          - `struct ShaderAsset` — shader, path, last_mtime, stage, num_uniform_buffers, num_storage_buffers, num_sampler_textures, dirty
          - `struct PipelineRecord` — vert_shader_key, frag_shader_key, needs_rebuild
          - `void AssetManager::init(SDL_GPUDevice *device)`
          - `SDL_GPUShader *AssetManager::load_shader(key, path, stage, num_uniform_buffers, num_storage_buffers, num_sampler_textures)`
          - `SDL_GPUShader *AssetManager::load_compute_shader(key, path, num_uniform_buffers, num_rw_storage_buffers, num_ro_storage_buffers)`
          - `void AssetManager::register_pipeline(key, vert_key, frag_key)`
          - `void AssetManager::register_compute_pipeline(key, shader_key)`
          - `void AssetManager::check_for_updates()`
          - `bool AssetManager::pipeline_needs_rebuild(key) const`
          - `void AssetManager::clear_rebuild_flag(key)`
          - `void AssetManager::register_buffer(key, SDL_GPUBuffer *buffer)`
          - `SDL_GPUBuffer *AssetManager::get_buffer(key) const`
          - `void AssetManager::release_buffer(key)`
          - `void AssetManager::clear()`
          - `void AssetManager::render_debug_ui() const`
        - asset_manager.cpp
          - `static uint64_t AssetManager::get_mtime(const std::string &path)`
          - `SDL_GPUShader *AssetManager::create_shader_internal(const ShaderAsset &meta)`
          - `void AssetManager::init(SDL_GPUDevice *device)`
          - `SDL_GPUShader *AssetManager::load_shader(...)`
          - `SDL_GPUShader *AssetManager::load_compute_shader(...)`
          - `void AssetManager::register_pipeline(...)`
          - `void AssetManager::register_compute_pipeline(...)`
          - `void AssetManager::check_for_updates()`
          - `bool AssetManager::pipeline_needs_rebuild(const std::string &key) const`
          - `void AssetManager::clear_rebuild_flag(const std::string &key)`
          - `void AssetManager::register_buffer(const std::string &key, SDL_GPUBuffer *buffer)`
          - `SDL_GPUBuffer *AssetManager::get_buffer(const std::string &key) const`
          - `void AssetManager::release_buffer(const std::string &key)`
          - `void AssetManager::clear()`
          - `void AssetManager::render_debug_ui() const`
        - debug.h
          - `public: static DebugTracker& get()`
          - `void push(const char* file, int line, const char* func, const char* message = nullptr)`
          - `void print_last()`
        - types.h
      - gpu/
        - gpu.cpp
          - `void UploadManager::init(SDL_GPUDevice *device, uint32_t size)`
          - `void UploadManager::cleanup(SDL_GPUDevice *device)`
          - `void *UploadManager::alloc(uint32_t size, uint32_t *out_offset)` — 256-byte aligned linear alloc from persistent staging buffer
          - `void UploadManager::reset()` — reset cursor to 0, call once per frame
          - `bool gpu_init(GpuContext &ctx)` — initializes UploadManager with 8MB
          - `bool gpu_create_game_window(GpuContext &ctx)`
          - `void gpu_destroy_game_window(GpuContext &ctx)`
          - `bool gpu_acquire_frame(GpuContext &ctx, FrameContext &frame)`
          - `bool gpu_acquire_game_frame(GpuContext &ctx, FrameContext &frame)` — calls upload_manager.reset()
          - `bool gpu_begin_render_pass(GpuContext &ctx, FrameContext &frame)`
          - `void gpu_end_frame(FrameContext &frame)`
          - `void gpu_blit_texture(FrameContext &frame, const TextureHandle &tex, const ViewState &view)`
          - `void gpu_cleanup(GpuContext &ctx)` — calls upload_manager.cleanup()
          - `void release_texture(SDL_GPUDevice *device, const TextureHandle &handle)`
          - `TextureHandle upload_pixels_to_texture(SDL_GPUDevice *device, const uint32_t *pixels, int width, int height)`
          - `SDL_GPUBuffer *gpu_create_buffer(SDL_GPUDevice *device, uint32_t size, SDL_GPUBufferUsageFlags usage)`
          - `SDL_GPUBuffer *gpu_upload_buffer(SDL_GPUDevice *device, const void *data, uint32_t size, SDL_GPUBufferUsageFlags usage)` — creates buffer, uploads via transfer, waits for idle
          - `SDL_GPUBuffer *gpu_create_zeroed_buffer(SDL_GPUDevice *device, uint32_t size, SDL_GPUBufferUsageFlags usage)` — zero-filled via gpu_upload_buffer
        - gpu.h
          - `struct UploadManager` — persistent mapped staging buffer; fields: buffer, mapped, capacity, cursor
          - `struct GpuContext` — window, game_window, device, upload_manager (UploadManager)
          - `bool gpu_init(GpuContext &ctx)`
          - `bool gpu_create_game_window(GpuContext &ctx)`
          - `void gpu_destroy_game_window(GpuContext &ctx)`
          - `bool gpu_acquire_frame(GpuContext &ctx, FrameContext &frame)`
          - `bool gpu_acquire_game_frame(GpuContext &ctx, FrameContext &frame)`
          - `bool gpu_begin_render_pass(GpuContext &ctx, FrameContext &frame)`
          - `void gpu_end_frame(FrameContext &frame)`
          - `void gpu_blit_texture(FrameContext &frame, const TextureHandle &tex, const ViewState &view)`
          - `void gpu_cleanup(GpuContext &ctx)`
          - `void release_texture(SDL_GPUDevice *device, const TextureHandle &handle)`
          - `TextureHandle upload_pixels_to_texture(SDL_GPUDevice *device, const uint32_t *pixels, int width, int height)`
          - `SDL_GPUBuffer *gpu_create_buffer(SDL_GPUDevice *device, uint32_t size, SDL_GPUBufferUsageFlags usage)`
          - `SDL_GPUBuffer *gpu_upload_buffer(SDL_GPUDevice *device, const void *data, uint32_t size, SDL_GPUBufferUsageFlags usage)`
          - `SDL_GPUBuffer *gpu_create_zeroed_buffer(SDL_GPUDevice *device, uint32_t size, SDL_GPUBufferUsageFlags usage)`
      - input/
        - input.cpp
          - `void InputSystem::init()`
          - `void InputSystem::begin_frame()`
          - `void InputSystem::handle_event(const SDL_Event &event)`
          - `void InputSystem::bind(SDL_Scancode key, Action action)`
        - input.h
          - `public: void init()`
          - `void begin_frame()`
          - `void handle_event(const SDL_Event &event)`
          - `void bind(SDL_Scancode key, Action action)`
      - render/
        - background.cpp
          - `bool BackgroundRenderer::build_pipeline(SDL_GPUTextureFormat swapchain_format, SDL_GPUTextureFormat depth_format)`
          - `bool BackgroundRenderer::init(SDL_GPUDevice *device, SDL_GPUTextureFormat swapchain_format, SDL_GPUTextureFormat depth_format, AssetManager &am)`
          - `void BackgroundRenderer::rebuild_if_dirty(SDL_GPUTextureFormat swapchain_format, SDL_GPUTextureFormat depth_format)`
          - `void BackgroundRenderer::draw(SDL_GPUCommandBuffer *cmd, SDL_GPURenderPass *render_pass, float time, float cam_x, float cam_y)`
          - `void BackgroundRenderer::cleanup()`
        - background.h
          - `public: bool init(SDL_GPUDevice *device, SDL_GPUTextureFormat swapchain_format, SDL_GPUTextureFormat depth_format, AssetManager &am)`
          - `void draw(SDL_GPUCommandBuffer *cmd, SDL_GPURenderPass *render_pass, float time, float cam_x, float cam_y)`
          - `void rebuild_if_dirty(SDL_GPUTextureFormat swapchain_format, SDL_GPUTextureFormat depth_format)`
          - `void cleanup()`
        - render_system.cpp
          - `static uint32_t alpha_blend_rs(uint32_t src, uint32_t dst, float alpha)`
          - `void RenderSystem::render_entities(flecs::world &world, std::vector<uint32_t> &pixels, int view_width, int view_height, float offset_x, float offset_y, const IsometricParams &params, const CameraState &camera, const SpriteManager &sprites, WorldToIsoFn world_to_iso_fn)`
          - `void RenderSystem::blit_sprite(std::vector<uint32_t> &pixels, int view_width, int view_height, const SpriteSheet &sheet, const SpriteFrame &frame, int dst_x, int dst_y, bool flip_x)`
        - render_system.h
          - `void render_entities(flecs::world &world, std::vector<uint32_t> &pixels, int view_width, int view_height, float offset_x, float offset_y, const IsometricParams &params, const CameraState &camera, const SpriteManager &sprites, WorldToIsoFn world_to_iso_fn)`
          - `private: void blit_sprite(std::vector<uint32_t> &pixels, int view_width, int view_height, const SpriteSheet &sheet, const SpriteFrame &frame, int dst_x, int dst_y, bool flip_x)`
        - sprite.cpp
          - `int SpriteManager::load_sheet(SDL_GPUDevice *device, const std::string &path, int frame_width, int frame_height)`
          - `int SpriteManager::load_sheet_from_pixels(SDL_GPUDevice *device, const uint32_t *pixels, int width, int height, int frame_width, int frame_height)`
          - `void SpriteManager::cleanup(SDL_GPUDevice *device)`
        - sprite.h
          - `public: int load_sheet(SDL_GPUDevice *device, const std::string &path, int frame_width, int frame_height)`
          - `int load_sheet_from_pixels(SDL_GPUDevice *device, const uint32_t *pixels, int width, int height, int frame_width, int frame_height)`
          - `void cleanup(SDL_GPUDevice *device)`
      - ui/
        - imgui_ui.cpp
          - `void ui_init(SDL_Window *window, SDL_GPUDevice *device)`
          - `void ui_shutdown()`
          - `void ui_process_event(SDL_Event &event)`
          - `void ui_begin_frame()`
          - `void ui_end_frame()`
          - `void ui_prepare_draw(SDL_GPUCommandBuffer *cmd)`
          - `void ui_draw(SDL_GPUCommandBuffer *cmd, SDL_GPURenderPass *render_pass)`
        - imgui_ui.h
          - `void ui_init(SDL_Window *window, SDL_GPUDevice *device)`
          - `void ui_shutdown()`
          - `void ui_process_event(SDL_Event &event)`
          - `void ui_begin_frame()`
          - `void ui_end_frame()`
          - `void ui_prepare_draw(SDL_GPUCommandBuffer *cmd)`
          - `void ui_draw(SDL_GPUCommandBuffer *cmd, SDL_GPURenderPass *render_pass)`
    - game/
      - config.h
      - game_state.h
        - `struct TerrainState` — use_isometric, current_palette, map_scale, contour_opacity, need_regenerate (plain ECS component, copyable)
        - `struct AsyncTerrainState` — is_generating (atomic), pending_mesh/map/contours (shared_ptr), pending_mtx (mutex); NOT a flecs component, owned by TopoGame
        - `struct GamePhase`, `struct WindowState`, `struct PointLightComponent`, `struct ContourData`
      - main.cpp
        - `int main()`
      - topo_game.cpp
        - `static json params_to_json(const ElevationParams &elev, const WorleyParams &worley, const CompositionParams &comp, const TerrainState &ts)`
        - `static void json_to_params(const json &j, ElevationParams &elev, WorleyParams &worley, CompositionParams &comp, TerrainState &ts)`
        - `void TopoGame::on_init(GpuContext &gpu, flecs::world &ecs)` — calls task_system.init(1)
        - `void TopoGame::on_event(const SDL_Event &event, flecs::world &ecs)`
        - `void TopoGame::on_render_tool(GpuContext &gpu, FrameContext &frame, flecs::world &ecs)`
        - `void TopoGame::on_pre_frame_game(GpuContext &gpu, flecs::world &ecs)` — called before gpu_acquire_game_frame; if ready_mesh_pending is set and terrain_renderer is initialized, calls terrain_renderer.upload_mesh (safe: no frame cmd buffer open), swaps ECS MapData/ContourData, frees old data on worker thread, clears ready_*_pending fields
        - `void TopoGame::on_render_game(GpuContext &gpu, FrameContext &frame, flecs::world &ecs)` — async regen: kicks worker via task_system.enqueue; polls async_terrain and moves completed results into ready_mesh_pending/ready_map_pending/ready_contours_pending (does NOT call upload_mesh here); calls terrain_renderer.draw(..., gpu.upload_manager)
        - `void TopoGame::on_cleanup(flecs::world &ecs)` — calls task_system.shutdown() before terrain_renderer.cleanup()
        - `bool TopoGame::wants_game_window_open(flecs::world &ecs)`
        - `bool TopoGame::wants_game_window_close(flecs::world &ecs)`
        - `void TopoGame::render_ui(flecs::world &ecs, bool game_window_open)`
        - `std::ofstream f("config.json")`
        - `std::ifstream f("config.json")`
      - topo_game.h
        - `TaskSystem task_system` — member; init(1) in on_init, shutdown() in on_cleanup before terrain_renderer.cleanup()
        - `AsyncTerrainState async_terrain` — member; holds is_generating, pending_mesh/map/contours, pending_mtx
        - `std::shared_ptr<TerrainMesh> ready_mesh_pending` — private; set in on_render_game when async results arrive, consumed in on_pre_frame_game
        - `std::shared_ptr<MapData> ready_map_pending` — private; same lifecycle as ready_mesh_pending
        - `std::shared_ptr<ContourData> ready_contours_pending` — private; same lifecycle as ready_mesh_pending
        - `private: void render_ui(flecs::world &ecs, bool game_window_open)`
      - terrain/
        - FastNoiseLite.h
          - `void SetSeed(int seed)`
          - `void SetFrequency(float frequency)`
          - `void SetNoiseType(NoiseType noiseType)`
          - `void SetRotationType3D(RotationType3D rotationType3D)`
          - `void SetFractalType(FractalType fractalType)`
          - `void SetFractalOctaves(int octaves)`
          - `void SetFractalLacunarity(float lacunarity)`
          - `void SetFractalGain(float gain)`
          - `void SetFractalWeightedStrength(float weightedStrength)`
          - `void SetFractalPingPongStrength(float pingPongStrength)`
          - `void SetCellularDistanceFunction( CellularDistanceFunction cellularDistanceFunction)`
          - `void SetCellularReturnType(CellularReturnType cellularReturnType)`
          - `void SetCellularJitter(float cellularJitter)`
          - `void SetDomainWarpType(DomainWarpType domainWarpType)`
          - `void SetDomainWarpAmp(float domainWarpAmp)`
          - `float GetNoise(FNfloat x, FNfloat y, FNfloat z) const`
          - `void DomainWarp(FNfloat &x, FNfloat &y, FNfloat &z) const`
          - `static float FastMin(float a, float b)`
          - `static float FastMax(float a, float b)`
          - `static float FastAbs(float f)`
          - `static float FastSqrt(float f)`
          - `static float Lerp(float a, float b, float t)`
          - `static float InterpHermite(float t)`
          - `static float InterpQuintic(float t)`
          - `static float CubicLerp(float a, float b, float c, float d, float t)`
          - `static float PingPong(float t)`
          - `void CalculateFractalBounding()`
          - `static int Hash(int seed, int xPrimed, int yPrimed)`
          - `static int Hash(int seed, int xPrimed, int yPrimed, int zPrimed)`
          - `static float ValCoord(int seed, int xPrimed, int yPrimed)`
          - `static float ValCoord(int seed, int xPrimed, int yPrimed, int zPrimed)`
          - `float GradCoord(int seed, int xPrimed, int yPrimed, float xd, float yd) const`
          - `float GradCoord(int seed, int xPrimed, int yPrimed, int zPrimed, float xd, float yd, float zd) const`
          - `void GradCoordOut(int seed, int xPrimed, int yPrimed, float &xo, float &yo) const`
          - `void GradCoordOut(int seed, int xPrimed, int yPrimed, int zPrimed, float &xo, float &yo, float &zo) const`
          - `void GradCoordDual(int seed, int xPrimed, int yPrimed, float xd, float yd, float &xo, float &yo) const`
          - `void GradCoordDual(int seed, int xPrimed, int yPrimed, int zPrimed, float xd, float yd, float zd, float &xo, float &yo, float &zo) const`
          - `float GenNoiseSingle(int seed, FNfloat x, FNfloat y) const`
          - `float GenNoiseSingle(int seed, FNfloat x, FNfloat y, FNfloat z) const`
          - `void TransformNoiseCoordinate(FNfloat &x, FNfloat &y) const`
          - `void TransformNoiseCoordinate(FNfloat &x, FNfloat &y, FNfloat &z) const`
          - `void UpdateTransformType3D()`
          - `void TransformDomainWarpCoordinate(FNfloat &x, FNfloat &y) const`
          - `void TransformDomainWarpCoordinate(FNfloat &x, FNfloat &y, FNfloat &z) const`
          - `void UpdateWarpTransformType3D()`
          - `float GenFractalFBm(FNfloat x, FNfloat y, FNfloat z) const`
          - `float GenFractalRidged(FNfloat x, FNfloat y) const`
          - `float GenFractalRidged(FNfloat x, FNfloat y, FNfloat z) const`
          - `float GenFractalPingPong(FNfloat x, FNfloat y) const`
          - `float GenFractalPingPong(FNfloat x, FNfloat y, FNfloat z) const`
          - `float SingleSimplex(int seed, FNfloat x, FNfloat y) const`
          - `float SingleOpenSimplex2(int seed, FNfloat x, FNfloat y, FNfloat z) const`
          - `float SingleOpenSimplex2S(int seed, FNfloat x, FNfloat y) const`
          - `float SingleOpenSimplex2S(int seed, FNfloat x, FNfloat y, FNfloat z) const`
          - `float SingleCellular(int seed, FNfloat x, FNfloat y) const`
          - `float SingleCellular(int seed, FNfloat x, FNfloat y, FNfloat z) const`
          - `float SinglePerlin(int seed, FNfloat x, FNfloat y) const`
          - `float SinglePerlin(int seed, FNfloat x, FNfloat y, FNfloat z) const`
          - `float SingleValueCubic(int seed, FNfloat x, FNfloat y) const`
          - `float SingleValueCubic(int seed, FNfloat x, FNfloat y, FNfloat z) const`
          - `float SingleValue(int seed, FNfloat x, FNfloat y) const`
          - `float SingleValue(int seed, FNfloat x, FNfloat y, FNfloat z) const`
          - `void DoSingleDomainWarp(int seed, float amp, float freq, FNfloat x, FNfloat y, FNfloat &xr, FNfloat &yr) const`
          - `void DoSingleDomainWarp(int seed, float amp, float freq, FNfloat x, FNfloat y, FNfloat z, FNfloat &xr, FNfloat &yr, FNfloat &zr) const`
          - `void DomainWarpSingle(FNfloat &x, FNfloat &y) const`
          - `void DomainWarpSingle(FNfloat &x, FNfloat &y, FNfloat &z) const`
          - `void DomainWarpFractalProgressive(FNfloat &x, FNfloat &y) const`
          - `void DomainWarpFractalProgressive(FNfloat &x, FNfloat &y, FNfloat &z) const`
          - `void DomainWarpFractalIndependent(FNfloat &x, FNfloat &y) const`
          - `void DomainWarpFractalIndependent(FNfloat &x, FNfloat &y, FNfloat &z) const`
          - `void SingleDomainWarpBasicGrid(int seed, float warpAmp, float frequency, FNfloat x, FNfloat y, FNfloat &xr, FNfloat &yr) const`
          - `void SingleDomainWarpBasicGrid(int seed, float warpAmp, float frequency, FNfloat x, FNfloat y, FNfloat z, FNfloat &xr, FNfloat &yr, FNfloat &zr) const`
          - `void SingleDomainWarpSimplexGradient(int seed, float warpAmp, float frequency, FNfloat x, FNfloat y, FNfloat &xr, FNfloat &yr, bool outGradOnly) const`
          - `void SingleDomainWarpOpenSimplex2Gradient(int seed, float warpAmp, float frequency, FNfloat x, FNfloat y, FNfloat z, FNfloat &xr, FNfloat &yr, FNfloat &zr, bool outGradOnly) const`
        - basalt.cpp
          - `static float sample_bilinear(const std::vector<float> &map, int width, int height, float fx, float fy)`
          - `static bool hex_fits_in_plateau(int q, int r, float hex_size, std::span<const int16_t> terrain_map, int16_t plateau_id, int width, int height)`
          - `std::vector<HexColumn> generate_basalt_columns(std::span<const float> heightmap, int width, int height, float hex_size, const std::vector<Plateau> &plateaus, std::vector<int> &plateaus_with_columns_out, std::vector<int16_t> &terrain_map)`
          - `std::vector<HexColumn> generate_basalt_columns_v2(MapData &data, float hex_size, const WorleyBasaltParams &params)`
          - `void render_basalt_columns(std::vector<uint32_t> &pixels, int view_width, int view_height, const std::vector<HexColumn> &columns, float hex_size, float offset_x, float offset_y, const IsometricParams &params, const Palette &palette)`
        - basalt.h
          - `std::vector<HexColumn> generate_basalt_columns(std::span<const float> heightmap, int width, int height, float hex_size, const std::vector<Plateau> &plateaus, std::vector<int> &plateaus_with_columns_out, std::vector<int16_t> &terrain_map)`
          - `std::vector<HexColumn> generate_basalt_columns_v2(MapData &data, float hex_size, const WorleyBasaltParams &params = {})`
          - `void render_basalt_columns(std::vector<uint32_t> &pixels, int view_width, int view_height, const std::vector<HexColumn> &columns, float hex_size, float offset_x, float offset_y, const struct IsometricParams &params, const struct Palette &palette)`
        - color.h
          - `inline uint32_t lerp_color(uint32_t c1, uint32_t c2, float t)`
          - `inline uint32_t add_noise_variation(uint32_t color, int x, int y, float strength = 0.08f)`
          - `inline uint32_t darken_color(uint32_t color, float darkness)`
          - `inline uint32_t alpha_blend(uint32_t src, uint32_t dst, float alpha)`
          - `inline uint32_t modulate_color(uint32_t color, float factor)`
          - `inline void apply_hex_dither(std::vector<uint32_t> &pixels, int width, int height, float strength, uint32_t skip_color = 0)`
        - contour.cpp
          - `void extract_contours(std::span<const float> heightmap, int width, int height, float interval, std::vector<Line> &out_lines, std::vector<int> &out_band_map)`
          - `void simplify_contours(std::vector<Line> &lines, float epsilon)` — erases degenerate segments via std::remove_if on squared length
          - `std::vector<Plateau> detect_plateaus(std::span<const int> band_map, std::span<const float> heightmap, int width, int height, std::vector<int16_t>& terrain_map)`
          - `std::vector<bool> visited(width * height, false)`
        - contour.h
          - `void extract_contours(std::span<const float> heightmap, int width, int height, float interval, std::vector<Line> &out_lines, std::vector<int> &out_band_map)`
          - `void simplify_contours(std::vector<Line> &lines, float epsilon)` — removes segments shorter than epsilon (world units); called after extract_contours in async regen lambda
          - `std::vector<Plateau> detect_plateaus(std::span<const int> band_map, std::span<const float> heightmap, int width, int height, std::vector<int16_t>& terrain_map)`
        - delve_render.cpp
          - `static void draw_line_soft(std::vector<uint32_t> &pixels, int width, int height, float x0, float y0, float x1, float y1, uint32_t color)`
          - `PixelBuffer generate_map_pixels(std::span<const float> heightmap, std::span<const int> band_map, std::span<const Line> contour_lines, int width, int height, bool use_isometric, const Palette &palette, const DetailParams &detail_params, float contour_opacity, float iso_padding, float iso_offset_x_adjust, float iso_offset_y_adjust)`
        - delve_render.h
          - `PixelBuffer generate_map_pixels(std::span<const float> heightmap, std::span<const int> band_map, std::span<const Line> contour_lines, int width, int height, bool use_isometric, const Palette &palette, const DetailParams &detail_params, float contour_opacity, float iso_padding, float iso_offset_x_adjust, float iso_offset_y_adjust)`
        - detail.cpp
          - `void add_procedural_details(std::vector<uint32_t> &pixels, std::span<const float> heightmap, int width, int height, const Palette &palette, const DetailParams &params)`
        - detail.h
          - `void add_procedural_details(std::vector<uint32_t> &pixels, std::span<const float> heightmap, int width, int height, const Palette &palette, const DetailParams &params)`
        - flood_fill.h
          - `std::vector<std::vector<int>> flood_fill_regions(int width, int height, Pred should_include, int min_region_size = 0)`
          - `std::vector<uint8_t> visited(width * height, 0)`
        - hex.cpp
          - `void hex_to_pixel(int q, int r, float hex_size, float &out_x, float &out_y)`
          - `HexCoord pixel_to_hex(float x, float y, float hex_size)`
          - `void get_hex_corners(int q, int r, float hex_size, Vec2 corners[6])`
          - `bool pixel_in_hex(float px, float py, int q, int r, float hex_size)`
          - `void project_hex_to_iso(const Vec2 corners[6], float z, const IsometricParams &params, IsoVec2 iso_corners[6])`
          - `bool point_in_hex_iso(float px, float py, const IsoVec2 corners[6])`
          - `void compute_visible_edges(std::vector<HexColumn> &columns)`
          - `void draw_filled_hex_top(std::vector<uint32_t> &pixels, int width, int height, const IsoVec2 iso_corners[6], float offset_x, float offset_y, uint32_t color)`
          - `void draw_side_face_filled(std::vector<uint32_t> &pixels, int width, int height, const Vec2 &corner0, const Vec2 &corner1, float top_height, float bottom_height, const IsometricParams &params, float offset_x, float offset_y, uint32_t base_color)`
        - hex.h
          - `void hex_to_pixel(int q, int r, float hex_size, float &out_x, float &out_y)`
          - `HexCoord pixel_to_hex(float x, float y, float hex_size)`
          - `void get_hex_corners(int q, int r, float hex_size, Vec2 corners[6])`
          - `bool pixel_in_hex(float px, float py, int q, int r, float hex_size)`
          - `void project_hex_to_iso(const Vec2 corners[6], float z, const IsometricParams &params, IsoVec2 iso_corners[6])`
          - `bool point_in_hex_iso(float px, float py, const IsoVec2 corners[6])`
          - `void compute_visible_edges(std::vector<HexColumn> &columns)`
          - `void draw_filled_hex_top(std::vector<uint32_t> &pixels, int width, int height, const IsoVec2 iso_corners[6], float offset_x, float offset_y, uint32_t color)`
          - `void draw_side_face_filled(std::vector<uint32_t> &pixels, int width, int height, const Vec2 &corner0, const Vec2 &corner1, float top_height, float bottom_height, const IsometricParams &params, float offset_x, float offset_y, uint32_t base_color)`
        - isometric.cpp
          - `void world_to_iso(float x, float y, float z, float &out_x, float &out_y, const IsometricParams &params)`
          - `void iso_to_world(float iso_x, float iso_y, float &out_x, float &out_y, const IsometricParams &params)`
          - `static void draw_line_iso(std::vector<uint32_t> &pixels, int width, int height, float x0, float y0, float x1, float y1, uint32_t color)`
          - `PixelBuffer create_isometric_heightmap( std::span<const float> heightmap, std::span<const int> band_map, std::span<const Line> contour_lines, int map_width, int map_height, const IsometricParams &params, const Palette &palette, float contour_opacity, float padding, float offset_x_adjust, float offset_y_adjust)`
        - isometric.h
          - `void world_to_iso(float x, float y, float z, float &out_x, float &out_y, const IsometricParams &params)`
          - `void iso_to_world(float iso_x, float iso_y, float &out_x, float &out_y, const IsometricParams &params)`
          - `PixelBuffer create_isometric_heightmap( std::span<const float> heightmap, std::span<const int> band_map, std::span<const Line> contour_lines, int map_width, int map_height, const IsometricParams &params, const Palette &palette, float contour_opacity, float padding, float offset_x_adjust, float offset_y_adjust)`
        - lava.cpp
          - `static float poly_area(const std::vector<P2> &P)`
          - `static bool point_in_tri(const P2 &p, const P2 &a, const P2 &b, const P2 &c)`
          - `static bool is_ear(int i0, int i1, int i2, const std::vector<int> &idx, const std::vector<P2> &P)`
          - `static void triangulate_ear_clipping(const std::vector<P2> &P, std::vector<int> &tri_indices)`
          - `static void trace_outline_4connected(const std::vector<uint8_t> &mask, int W, int H, std::vector<P2> &out_poly)`
          - `static void generate_lava_grid_mesh(LavaBody &lava, int width, int height, float grid_spacing)`
          - `std::vector<int> vertex_map(nx * ny, -1)`
          - `static void build_triangle_mesh_from_polygon(const std::vector<P2> &poly, float z, LavaMesh &mesh_out)`
          - `std::vector<ChannelRegion> extract_channel_spaces(std::span<const int16_t> terrain_map, int width, int height, std::span<const float> heightmap)`
          - `std::vector<uint8_t> visited(width * height, 0)`
          - `std::vector<ChannelRegion> subdivide_large_regions(const std::vector<ChannelRegion> &regions, const std::vector<HexColumn> &columns, int width, int height)`
          - `std::vector<uint8_t> mask(width * height, 0)`
          - `static void fill_holes_in_region(ChannelRegion &region, int width, int height)`
          - `std::vector<ChannelRegion> filter_lava_channels(const std::vector<ChannelRegion> &regions, std::span<const float> heightmap, int width, int height)`
          - `static void densify_region(std::vector<int> &pixels, int width, int height)`
          - `static LavaBody channel_to_lava_body(const ChannelRegion &channel, std::span<const float> heightmap, int width, int height, int channel_idx)`
          - `std::vector<uint8_t> mask(width * height, 0)`
          - `std::vector<LavaBody> channels_to_lava_bodies(const std::vector<ChannelRegion> &channels, std::span<const float> heightmap, int width, int height)`
          - `std::vector<LavaBody> identify_lava_bodies(std::span<const float> heightmap, int width, int height, const std::vector<Plateau> &plateaus, const std::vector<int> &plateaus_with_columns)`
          - `std::mt19937 rng(seed)`
          - `float get_lava_height(float x, float y, float base_z, float time, float time_offset)`
          - `void render_lava(std::vector<uint32_t> &pixels, int view_w, int view_h, const std::vector<LavaBody> &lava_bodies, float off_x, float off_y, const IsometricParams &params, float time)`
          - `FloodFillResult generate_lava_and_void(MapData &data, float void_chance, int seed)`
          - `std::vector<bool> visited(n, false)`
          - `std::mt19937 rng(rng_seed)`
          - `std::uniform_real_distribution<float> dist(0.0f, 1.0f)`
        - lava.h
          - `std::vector<ChannelRegion> extract_channel_spaces(std::span<const int16_t> terrain_map, int width, int height, std::span<const float> heightmap)`
          - `std::vector<ChannelRegion> filter_lava_channels(const std::vector<ChannelRegion> &regions, std::span<const float> heightmap, int width, int height)`
          - `std::vector<LavaBody> channels_to_lava_bodies(const std::vector<ChannelRegion> &channels, std::span<const float> heightmap, int width, int height)`
          - `std::vector<LavaBody> identify_lava_bodies(std::span<const float> heightmap, int width, int height, const std::vector<Plateau> &plateaus, const std::vector<int> &plateaus_with_columns)`
          - `void generate_lava_mesh_masked(LavaBody &lava, const std::vector<uint8_t> &mask, int mask_w, int mask_h, float grid_spacing)`
          - `float get_lava_height(float x, float y, float base_z, float time, float time_offset)`
          - `FloodFillResult generate_lava_and_void(MapData &data, float void_chance, int seed = 0)`
          - `void render_lava(std::vector<uint32_t> &pixels, int view_width, int view_height, const std::vector<LavaBody> &lava_bodies, float offset_x, float offset_y, const struct IsometricParams &params, float time)`
        - map_data.h
          - `void allocate(int w, int h)`
        - map_gen.cpp
        - map_gen.h
        - noise.cpp
          - `void generate_heightmap(std::span<float> out, int width, int height, const NoiseParams &params, float map_scale)`
          - `std::vector<float> gradient_x(width * height, 0.0f)`
          - `std::vector<float> gradient_y(width * height, 0.0f)`
          - `FastNoiseLite noise(params.seed)`
          - `std::vector<float> octave_values(width * height)`
          - `std::vector<float> smoothed(width * height)`
          - `std::vector<bool> visited(width * height, false)`
        - noise.h
          - `void generate_heightmap(std::span<float> out, int width, int height, const NoiseParams &params, float map_scale = 1.0f)`
        - noise_cache.h
          - `bool get(Slot slot, uint64_t param_hash, std::vector<float> &out) const`
          - `bool get2(Slot slot, uint64_t param_hash, std::vector<float> &out1, std::vector<float> &out2) const`
          - `bool get3(Slot slot, uint64_t param_hash, std::vector<float> &out1, std::vector<float> &out2, std::vector<float> &out3) const`
          - `void put(Slot slot, uint64_t param_hash, const std::vector<float> &data)`
          - `void put2(Slot slot, uint64_t param_hash, const std::vector<float> &data1, const std::vector<float> &data2)`
          - `void put3(Slot slot, uint64_t param_hash, const std::vector<float> &data1, const std::vector<float> &data2, const std::vector<float> &data3)`
          - `void invalidate_all()`
        - noise_composer.cpp
          - `static void cleanup_small_regions(std::vector<float> &heightmap, int width, int height, int min_region_size)`
          - `std::vector<bool> visited(n, false)`
          - `void compose_layers(MapData &data, const ElevationParams &elev, const RiverParams &river, const WorleyParams &worley, const CompositionParams &comp, NoiseCache *cache)`
        - noise_composer.h
          - `void compose_layers(MapData &data, const ElevationParams &elev, const RiverParams &river, const WorleyParams &worley, const CompositionParams &comp, NoiseCache *cache = nullptr)`
        - noise_layers.cpp
          - `static void seed_offset(int seed, float &ox, float &oy)`
          - `static float biased_smoothstep(float t, float bias)`
          - `void generate_elevation_layer(std::vector<float> &out, int width, int height, const ElevationParams &params)`
          - `std::vector<float> gradient_x(n, 0.0f)`
          - `std::vector<float> gradient_y(n, 0.0f)`
          - `FastNoiseLite noise(params.seed)`
          - `std::vector<float> octave_values(n)`
          - `void generate_river_mask(std::vector<float> &out, int width, int height, const RiverParams &params)`
          - `FastNoiseLite noise(params.seed)`
          - `void generate_worley_layer(std::vector<float> &out_value, std::vector<float> &out_edge, std::vector<float> &out_cell_value, int width, int height, const WorleyParams &params)`
          - `FastNoiseLite warp(params.seed + 31337)`
          - `FastNoiseLite noise_dist(params.seed)`
          - `FastNoiseLite noise_cell(params.seed)`
          - `FastNoiseLite noise_edge(params.seed)`
        - noise_layers.h
          - `void generate_elevation_layer(std::vector<float> &out, int width, int height, const ElevationParams &params)`
          - `void generate_river_mask(std::vector<float> &out, int width, int height, const RiverParams &params)`
          - `void generate_worley_layer(std::vector<float> &out_value, std::vector<float> &out_edge, std::vector<float> &out_cell_value, int width, int height, const WorleyParams &params)`
        - palettes.h
          - `inline uint32_t get_elevation_color_smooth(float h, const Palette &p)`
          - `inline uint32_t organic_color(float h, int x, int y, const Palette &p)`
          - `inline uint32_t get_elevation_color(float h, const Palette &p)`
        - terrain_generator.cpp
          - `TerrainGenerator::TerrainData TerrainGenerator::generate(std::span<const float> heightmap, std::span<const int> band_map, int width, int height)`
        - terrain_generator.h
          - `static TerrainData generate(std::span<const float> heightmap, std::span<const int> band_map, int width, int height)`
        - terrain_mesh.cpp
          - `static void color_to_float(uint32_t c, float &r, float &g, float &b)`
          - `static void add_hex_top(TerrainMesh &mesh, const Vec2 corners[6], float z, float offset_x, float offset_y, float cr, float cg, float cb, float global_depth_range, float sheen, TerrainMesh::RenderingLayer &layer)`
          - `static void add_side_face(TerrainMesh &mesh, const Vec2 &corner0, const Vec2 &corner1, float top_height, float bottom_height, const IsometricParams &params, float offset_x, float offset_y, float cr, float cg, float cb, float global_depth_range, float sheen, TerrainMesh::RenderingLayer &layer)`
          - `TerrainMesh build_terrain_mesh(const TerrainState &terrain, const MapData &map_data, const ContourData &contours)`
          - `SceneUniforms compute_uniforms(const MapData &map_data, const glm::mat4 &view, const glm::mat4 &projection, uint32_t cluster_tiles_x, uint32_t cluster_tiles_y, float time, float contour_opacity, uint32_t light_count)`
        - terrain_mesh.h
          - `TerrainMesh build_terrain_mesh(const TerrainState &terrain, const MapData &map_data, const ContourData &contours)`
          - `SceneUniforms compute_uniforms(const MapData &map_data, const glm::mat4 &view, const glm::mat4 &projection, uint32_t cluster_tiles_x, uint32_t cluster_tiles_y, float time, float contour_opacity, uint32_t light_count)`
          - `struct SceneUniforms` — glm::mat4 view, projection; float time, contour_opacity, hex_border_width; lava_color_r/g/b; star_light_r/g/b/intensity; light_dir_x/y/z/ambient; light_col_r/g/b; grid_size_x/y, num_slices, tile_px; near_plane, far_plane, light_count_f
          - `struct GpuPointLight` — pos_x/y/z, radius, color_r/g/b, intensity (32 bytes, std430)
          - `struct BasaltVertex` — pos_x/y/z, color_r/g/b, sheen, nx/ny/nz
          - `struct GpuLavaVertex` — pos_x/y/z, time_offset
          - `struct ContourVertex` — pos_x/y/z
        - terrain_renderer.cpp
          - `static SDL_GPUComputePipeline *build_compute_pipeline(SDL_GPUDevice *device, const char *path, int num_uniform_buffers, int num_rw_storage_buffers, int num_ro_storage_buffers)` — NOTE: buffer helpers (create_gpu_buffer, upload_to_gpu_buffer, create_zeroed_gpu_buffer) removed; use gpu.h free functions instead
          - `void TerrainRenderer::init(SDL_GPUDevice *device, SDL_Window *window, AssetManager &am)`
          - `void TerrainRenderer::init_graphics_pipelines(SDL_GPUDevice *device, SDL_Window *window)` — terrain.frag registered with num_storage_buffers=3 (point_light, light_grid, global_index)
          - `void TerrainRenderer::init_compute_pipelines(SDL_GPUDevice *device)`
          - `void TerrainRenderer::rebuild_dirty_pipelines(SDL_Window *window)` — terrain.frag rebuild also uses num_storage_buffers=3
          - `void TerrainRenderer::init_cluster_buffers(SDL_GPUDevice *device, uint32_t tilesX, uint32_t tilesY, uint32_t num_slices)`
          - `void TerrainRenderer::upload_mesh(SDL_GPUDevice *device, const TerrainMesh &mesh)` — uses gpu_upload_buffer / gpu_create_buffer from gpu.h
          - `void TerrainRenderer::upload_lights(SDL_GPUCommandBuffer *cmd, UploadManager &uploader, const std::vector<GpuPointLight> &lights)` — uses UploadManager for zero-alloc per-frame upload; falls back to one-shot transfer on overflow
          - `void TerrainRenderer::rebuild_clusters_if_needed(SDL_GPUCommandBuffer *cmd, uint32_t w, uint32_t h, float tile_px, uint32_t num_slices, float near_plane, float far_plane)`
          - `void TerrainRenderer::stage_geometry(SDL_GPURenderPass *pass, SDL_GPUCommandBuffer *cmd, const SceneUniforms &uniforms)` — dead code (not called from draw); binds all 3 storage buffers correctly
          - `void TerrainRenderer::stage_cull_lights(SDL_GPUCommandBuffer *cmd, const SceneUniforms &u, const std::vector<GpuPointLight> &lights)`
          - `void TerrainRenderer::stage_shaded_draw(SDL_GPURenderPass *pass, SDL_GPUCommandBuffer *cmd, const SceneUniforms &uniforms)` — now binds all 3 fragment storage buffers: point_light_ssbo, light_grid_ssbo, global_index_ssbo
          - `void TerrainRenderer::draw(SDL_GPUCommandBuffer *cmd, SDL_GPUTexture *swapchain, uint32_t w, uint32_t h, const SceneUniforms &uniforms, const std::vector<GpuPointLight> &lights, UploadManager &uploader)`
          - `void TerrainRenderer::release_buffers(SDL_GPUDevice *device)`
          - `void TerrainRenderer::release_cluster_buffers(SDL_GPUDevice *device)`
          - `void TerrainRenderer::cleanup(SDL_GPUDevice *device)`
        - terrain_renderer.h
          - `public: void init(SDL_GPUDevice *device, SDL_Window *window, AssetManager &am)`
          - `void upload_mesh(SDL_GPUDevice *device, const TerrainMesh &mesh)`
          - `void draw(SDL_GPUCommandBuffer *cmd, SDL_GPUTexture *swapchain, uint32_t w, uint32_t h, const SceneUniforms &uniforms, const std::vector<GpuPointLight> &lights, UploadManager &uploader)` — includes gpu/gpu.h for UploadManager
          - `void rebuild_clusters_if_needed(SDL_GPUCommandBuffer *cmd, uint32_t w, uint32_t h, float tile_px, uint32_t num_slices, float near_plane, float far_plane)`
          - `void rebuild_dirty_pipelines(SDL_Window *window)`
          - `SDL_GPURenderPass *begin_render_pass(SDL_GPUCommandBuffer *cmd, SDL_GPUTexture *swapchain, uint32_t w, uint32_t h)`
          - `SDL_GPURenderPass *begin_render_pass_load(SDL_GPUCommandBuffer *cmd, SDL_GPUTexture *swapchain, uint32_t w, uint32_t h)`
          - `void cleanup(SDL_GPUDevice *device)`
          - `bool is_initialized() const`
          - `bool has_mesh() const`
          - `SDL_GPUTextureFormat get_depth_format() const`
          - `uint32_t cluster_tiles_x() const`
          - `uint32_t cluster_tiles_y() const`
          - `private: void init_graphics_pipelines(SDL_GPUDevice *device, SDL_Window *window)`
          - `void init_compute_pipelines(SDL_GPUDevice *device)`
          - `void init_cluster_buffers(SDL_GPUDevice *device, uint32_t tilesX, uint32_t tilesY, uint32_t num_slices)`
          - `void stage_geometry(SDL_GPURenderPass *pass, SDL_GPUCommandBuffer *cmd, const SceneUniforms &uniforms)` — dead code, not called from draw()
          - `void stage_cull_lights(SDL_GPUCommandBuffer *cmd, const SceneUniforms &uniforms, const std::vector<GpuPointLight> &lights)`
          - `void stage_shaded_draw(SDL_GPURenderPass *pass, SDL_GPUCommandBuffer *cmd, const SceneUniforms &uniforms)`
          - `void release_buffers(SDL_GPUDevice *device)`
          - `void release_cluster_buffers(SDL_GPUDevice *device)`
          - `void upload_lights(SDL_GPUCommandBuffer *cmd, UploadManager &uploader, const std::vector<GpuPointLight> &lights)`
          - `AssetManager *asset_manager` — field
        - util.h
          - `inline uint32_t hash2d(int x, int y)`
          - `inline uint32_t hash1d(int idx)`
    - shaders/
      - background.frag.glsl
        - `float hash11(uint n) {`
        - `float hash21(uvec2 p) {`
        - `vec3 star_color_from_hash(uvec2 unc) {`
        - `float star_layer(vec2 frag_px, float t, float cell_px, float chance, float radius_scale, inout vec3 accumulated_color) {`
        - `void main() {`
      - background.vert.glsl
        - `void main() {`
      - common.glsl
        - `vec2 world_to_iso(vec3 world, float tile_width, float tile_height, float height_scale) {`
        - `vec3 world_normal_to_iso(vec3 n, float tile_width, float tile_height) {`
        - `vec2 iso_to_ndc(vec2 iso, vec4 proj_scale_offset) {`
      - contour.frag.glsl
        - `void main() {`
      - contour.vert.glsl
        - `void main() {`
      - coord.glsl
        - `vec2 world_to_iso_scene(vec3 world_pos) {`
        - `vec2 world_to_iso_scene_flat(vec2 world_xy) {`
        - `vec2 iso_scene_to_ndc(vec2 iso_scene_pos) {`
        - `vec2 world_to_ndc(vec3 world_pos) {`
        - `float painter_depth(vec3 world_pos) {`
        - `uint cluster_index() {`
      - generate_clusters.comp.glsl
        - `vec3 screenToView(vec2 screenPos) {`
        - `float sliceNear(float k) {`
        - `void main() {`
      - lava.frag.glsl
        - `void main() {`
      - lava.vert.glsl
        - `void main() {`
      - light_culling.comp.glsl
        - `float sqDistPointAABB(vec3 p, vec3 aabbMin, vec3 aabbMax) {`
        - `bool sphereAABB(vec3 center, float radius, vec3 aabbMin, vec3 aabbMax) {`
        - `vec3 iso_scene_to_cluster_space(vec3 iso_pos) {`
        - `void main() {`
      - lighting_common.glsl
      - terrain.frag.glsl
        - `vec3 applyPointLight(PointLight light, vec2 fragPos2D, vec3 normal, vec3 baseColor) {`
        - `vec3 apply_directional(vec3 color, vec3 normal) {`
        - `vec3 apply_star_ambient(vec3 color, vec3 normal, float sheen) {`
        - `void main() {`
      - terrain.vert.glsl
        - `void main() {`
